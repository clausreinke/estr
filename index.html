<!DOCTYPE html>
<html>

<head>
<title>estr demo</title>

<script src="CodeMirror2/lib/codemirror.js"></script>
<link rel="stylesheet" href="CodeMirror2/lib/codemirror.css">
<script src="CodeMirror2/mode/javascript/javascript.js"></script>

<script src="esprima.js"></script>
<script id="require">
function require(dependency) {
  return require.cache[dependency]
}
require.cache = { "./esprima.js": esprima };
</script>
<script src="ast_utils.js"></script>
<script src="scope_utils.js"></script>
</head>

<style>
textarea        { width: 100%; height: 10em }
.currentVar     { background-color: #CEFFCE }
.currentBinding { background-color: #B6EEE8 }
.currentUnbound { text-decoration: underline; background-color: red }
#occurrences    { border: thin solid; padding: 0.2em; color: #05a }
#next,#previous { background: #CEFFCE }
#binding        { background: #B6EEE8 }
.Error          { background: red !important}
.Warning        { background: yellow !important}
</style>

<body>
This is an in-browser demo of <a href="https://github.com/clausreinke/estr">estr</a>, built with <a href="http://esprima.org/">Esprima</a> and <a href="http://codemirror.net/">CodeMirror</a>.
<hr>

<textarea id="in">
</textarea>

<form action="#">
<input id="oldName" type='text' title='old name'>
<input id="rename" type='submit' value='rename'>
<input id="undo" type='submit' value='undo'>
<input id="redo" type='submit' value='redo'>
<span id="occurrences">
<input id="previous" type='submit' value='previous'>
<input id="binding" type='submit' value='binding'>
<input id="next" type='submit' value='next'>
</span>
</form>

<textarea id="out">
</textarea>

<script>
// TODO: - don't reparse on every move
//       - reparse on change, not on action
//       - shim forEach, .. for older browsers?
//       - state-dependent enable/disable of buttons
//       - clean up

var inArea  = document.getElementById('in');
var outArea = document.getElementById('out');

var rename    = require('./scope_utils.js').rename;
var findVar   = require('./scope_utils.js').findVar;
var parseThen = require('./ast_utils.js').parseThen;

// var source  = esprima.parse.toString();
var source  = renameAction.toString();

inArea.innerHTML = source;

var inCodeMirror  = CodeMirror.fromTextArea(inArea
                                           ,{onCursorActivity:onCursor
                                            ,gutter:true});
var outCodeMirror = CodeMirror.fromTextArea(outArea);

var currentVar      = null;
var currentVarMarks = [];

var currentErrorMarkers = [];

function onCursor(editor) {
    var coords = editor.getCursor(true);
    var token  = editor.getTokenAt(coords);
    console.log(token);
    if (token && token.className && token.className.match(/variable|def/)) {
      var result = parseThen(findVar(token.string,{line:coords.line+1
                                                  ,column:coords.ch}))
                            ('in',editor.getValue());

      currentVarMarks.forEach(function(mark){
        mark.clear();
      });
      currentVarMarks = [];
      currentVar      = null;

      currentErrorMarkers.forEach(function(line){
        editor.clearMarker(line);
      });
      currentErrorMarkers = [];
      outCodeMirror.setValue('');

      if (result) {
        if (result.parseError) {
          outCodeMirror.setValue('parse error in source:\n'
                                +result.parseError);
          console.error('parse error in source:',result.parseError);
          currentErrorMarkers.push(
            editor.setMarker(result.parseError.lineNumber-1,'!','Error')
          );
        } else if (result.error) {
          outCodeMirror.setValue(result.error.message);
          currentVarMarks.push(
            editor.markText({line:coords.line,ch:token.start}
                           ,{line:coords.line,ch:token.end}
                           ,'currentUnbound'));
        } else {
          if (result.warnings) {
            outCodeMirror.setValue(outCodeMirror.getValue()+'\n'+result.warnings);
            result.warnings.match(/start: { line: \d+/g)
                           .forEach(function(p){
                              currentErrorMarkers.push(
                                editor.setMarker(p.match(/\d+/)-1,'?','Warning')
                              );
                            });
          }
          document.getElementById('oldName').value = token.string;

          var bindLoc = result.binding[0].loc;
          currentVar  = result.binding;
          currentVarMarks.push(
            editor.markText({line:bindLoc.start.line-1,ch:bindLoc.start.column}
                           ,{line:bindLoc.end.line-1,  ch:bindLoc.end.column}
                           ,'currentBinding'));
          result.binding[0]
                .occurrences
                .forEach(function(o){
                          currentVarMarks.push(
                            editor.markText({line:o.loc.start.line-1
                                            ,ch:o.loc.start.column}
                                           ,{line:o.loc.end.line-1
                                            ,ch:o.loc.end.column}
                                           ,'currentVar'));
                         });
        }
      }
    } else {
      document.getElementById('oldName').value = ""; // +'('+token.className+')';
    }
};

function move(direction) { return function() {
  if (direction===0) {
    inCodeMirror.setCursor({line:currentVar[0].loc.start.line-1
                           ,ch:  currentVar[0].loc.start.column});
    return;
  }
  var coords = inCodeMirror.getCursor(true);
  var index = -1;
  for (var i=0; i<currentVarMarks.length; i++) {
    mark = currentVarMarks[i].find();
    if (mark.from.line===coords.line
     && mark.from.ch<=coords.ch
     && mark.to.ch>=coords.ch) {
      index = i;
      break;
    }
  }
  if (index>-1) {
    var target = (index+currentVarMarks.length+direction)%currentVarMarks.length;
    inCodeMirror.setCursor(currentVarMarks[target].find().from);
  }
} }

function renameAction() {
  try {
    var coords = inCodeMirror.getCursor(true);
    var token  = inCodeMirror.getTokenAt(coords);
    var newName = prompt('new name?','x____x');
    var output = [];

    var renamed =
      parseThen(rename(token.string,{line:coords.line+1,column:coords.ch},newName))
               ('in',inCodeMirror.getValue());
    if (renamed) {
      if (renamed.warnings) {
        output.push(renamed.warnings);
      }
      if (renamed.parseError) { // should have been handled by onCursor
        output.push(renamed.warnings);
      }
      if (renamed.error) {
        output.push(renamed.error.message);
        renamed.error.message.match(/line: \d+/g)
                       .forEach(function(p){
                          currentErrorMarkers.push(
                            inCodeMirror.setMarker(p.match(/\d+/)-1,'!','Error')
                          );
                        });
      } else {
        inCodeMirror.setValue(renamed.source);
      }
    }
    outCodeMirror.setValue(output.join('\n'));
  } catch (e) {
    console.error(e);
    outCodeMirror.setValue('renaming failed (see error log)\n'+e);
  }
}

function refocus(action,repos) { return function() {
  var coords = inCodeMirror.getCursor(true);
  action();
  inCodeMirror.focus();
  if (repos) inCodeMirror.setCursor(coords);
}}

document.getElementById('rename')
        .addEventListener('click',refocus(renameAction,true),false);
document.getElementById('undo')
        .addEventListener('click',refocus(inCodeMirror.undo,true),false);
document.getElementById('redo')
        .addEventListener('click',refocus(inCodeMirror.redo,true),false);
document.getElementById('next')
        .addEventListener('click',refocus(move(+1)),false);
document.getElementById('binding')
        .addEventListener('click',refocus(move(0)),false);
document.getElementById('previous')
        .addEventListener('click',refocus(move(-1)),false);

inCodeMirror.focus();

</script>

</body>

</html>
