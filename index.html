<!DOCTYPE html>
<html>

<head>
<title>estr demo</title>

<script src="CodeMirror3/lib/codemirror.js"></script>
<link rel="stylesheet" href="CodeMirror3/lib/codemirror.css">
<script src="CodeMirror3/mode/javascript/javascript.js"></script>

<script src="esprima.js"></script>
<script id="require">
function require(dependency) {
  return require.cache[dependency]
}
require.cache = { "./esprima.js": esprima };
</script>
<script src="ast_utils.js"></script>
<script src="scope_utils.js"></script>
</head>

<style>
textarea        { width: 100%; height: 10em }

.currentVar     { background-color: #CEFFCE }
.currentBinding { background-color: #B6EEE8 }
.currentUnbound { text-decoration: underline; background-color: red }
.Unbound        { /* text-decoration: underline; */
                  /* -moz-text-decoration-color: red; */
                  border-bottom: 1px solid red }

#occurrences    { border: thin solid; padding: 0.2em; color: #05a }
#next,#previous { background: #CEFFCE }
#binding        { background: #B6EEE8 }

.Error          { background: red !important}
.ParseError     { background: orange !important}
.Warning        { background: yellow !important}
</style>

<body>
<p>
This is an in-browser demo of <a
href="https://github.com/clausreinke/estr">estr</a>, built with <a
href="http://esprima.org/">Esprima</a> and <a
href="http://codemirror.net/">CodeMirror</a>. See <a
href="http://libraryinstitute.wordpress.com/2012/06/18/introducing-estr-es-traversals-and-transformations/">Introducing
ESTR</a> for a brief overview of estr.
</p>
<p id="explanation">
In the CodeMirror-enhanced textarea below, CodeMirror supplies editing and
basic Javascript syntax highlightling. On top of that, estr provides Javascript
scope information and source transformation: <em>move the cursor over a
variable to see all occurrences highlighted</em> (unbound variable occurrences
are underlined); you can then <em>navigate to the variable declaration</em>
(binding), <em>iterate through the occurrences</em>, or <em>rename all variable
occurrences</em>, using the buttons under the textarea.  Renaming is guarded by
checks that will prevent naming conflicts (try with your own code samples, and
please <a href="https://github.com/clausreinke/estr/issues/new" title="requires github login">file a bug</a> if you find a case where renaming breaks
scoping;-).
</p>
<hr>

<textarea id="in">
</textarea>

<form action="#">
<input id="oldName" type='text' title='old name'>
<input id="rename" type='submit' value='rename' disabled>
<input id="undo" type='submit' value='undo'>
<input id="redo" type='submit' value='redo'>
<span id="occurrences">
<input id="previous" type='submit' value='previous' disabled>
<input id="binding" type='submit' value='binding' disabled>
<input id="next" type='submit' value='next' disabled>
</span>
</form>

<textarea id="out">
</textarea>

<script>
// TODO: - shim forEach, bind, .. for older browsers?
//       - clean up
// TODO: - v3 has more flexible gutter markers - use

function element(tag,attributes,children) {
   var e = document.createElement(tag);
   for (var a in attributes) e.setAttribute(a,attributes[a]);
   for (var c in children) e.appendChild(children[c]);
   return e;
}

function text(txt) { return document.createTextNode(txt) }

function CodeMirrorFrame(editor) {
  this.editor = editor;

  this.currentVar = null;
  this.currentVarMarks = [];

  this.unboundMarks = [];

  this.currentParseErrorMarkers = [];
  this.currentErrorMarkers      = [];
  this.currentWarningMarkers    = [];

  this.currentAST = null;

}

CodeMirrorFrame.prototype.clearCurrentVar = function() {
      this.currentVarMarks.forEach(function(mark){
        mark.clear();
      });
      this.currentVarMarks = [];
      this.currentVar      = null;
      document.getElementById('previous').disabled = true;
      document.getElementById('binding').disabled  = true;
      document.getElementById('next').disabled     = true;
};

CodeMirrorFrame.prototype.setCurrentVar = function(binding) {
  var bindLoc     = binding[0].loc;
  this.currentVar = binding;
  this.currentVarMarks.push(
    this.editor.markText({line:bindLoc.start.line-1,ch:bindLoc.start.column}
                        ,{line:bindLoc.end.line-1,  ch:bindLoc.end.column}
                        ,'currentBinding'));
  binding[0].occurrences
         .forEach(function(o){
                    this.currentVarMarks.push(
                      this.editor.markText({line:o.loc.start.line-1
                                           ,ch:o.loc.start.column}
                                          ,{line:o.loc.end.line-1
                                           ,ch:o.loc.end.column}
                                          ,'currentVar'));
                  }.bind(this));
  document.getElementById('previous').disabled = false;
  document.getElementById('binding').disabled  = false;
  document.getElementById('next').disabled     = false;
};

CodeMirrorFrame.prototype.nextOccurrence =
  function(direction) { return function() {
    if (direction===0) {
      this.editor.setCursor({line:this.currentVar[0].loc.start.line-1
                            ,ch:  this.currentVar[0].loc.start.column});
      return;
    }
    var coords = this.editor.getCursor(true);
    var index = -1;
    for (var i=0; i<this.currentVarMarks.length; i++) {
      mark = this.currentVarMarks[i].find();
      if (mark.from.line===coords.line
       && mark.from.ch<=coords.ch
       && mark.to.ch>=coords.ch) {
        index = i;
        break;
      }
    }
    if (index>-1) {
      var target = (index+this.currentVarMarks.length+direction)
                 % this.currentVarMarks.length;
      var targetPos = this.currentVarMarks[target].find().from;
      this.editor.setCursor(targetPos);
    }
  }.bind(this);
};

CodeMirrorFrame.prototype.clearUnboundMarks = function() {
  this.unboundMarks.forEach(function(mark) { mark.clear() });
  this.unboundMarks = [];
};

errorDOM      = element('span',{'class':'Error'},[text('!')]);
parseErrorDOM = element('span',{'class':'ParseError'},[text('P')]);
warningDOM    = element('span',{'class':'Warning'},[text('?')]);

CodeMirrorFrame.prototype.parseError = function(e) {
    this.currentParseErrorMarkers.push(
      this.editor.setGutterMarker(e.lineNumber-1,'ParseError',parseErrorDOM)
    );
}

CodeMirrorFrame.prototype.warning = function(line) {
    this.currentWarningMarkers.push(
      this.editor.setGutterMarker(line,'Warning',warningDOM)
    );
}

CodeMirrorFrame.prototype.error = function(line) {
    this.currentErrorMarkers.push(
      this.editor.setGutterMarker(line,'Error',errorDOM)
    );
}

CodeMirrorFrame.prototype.clearErrors = function(parseErrors) {
  if (parseErrors) {
    this.currentParseErrorMarkers.forEach(function(line){
      this.editor.setGutterMarker(line,'ParseError',null);
    }.bind(this));
    this.currentParseErrorMarkers = [];
  }

  this.currentErrorMarkers.forEach(function(line){
    this.editor.setGutterMarker(line,'Error',null);
  }.bind(this));
  this.currentErrorMarkers = [];

  this.currentWarningMarkers.forEach(function(line){
    this.editor.setGutterMarker(line,'Warning',null);
  }.bind(this));
  this.currentWarningMarkers = [];
};

function navigation_disabled(flag) {
  document.getElementById('previous').disabled = flag;
  document.getElementById('binding').disabled  = flag;
  document.getElementById('next').disabled     = flag;
}

var inArea  = document.getElementById('in');
var outArea = document.getElementById('out');

var rename    = require('./scope_utils.js').rename;
var findVar   = require('./scope_utils.js').findVar;
var parseThen = require('./ast_utils.js').parseThen;
var parse     = require('./esprima.js').parse;

// var source  = esprima.parse.toString();
var source  = renameAction.toString();

var inCodeMirror  = CodeMirror.fromTextArea(inArea,{gutter:true
                                                   ,gutters:['ParseError','Error','Warning']});
inCodeMirror.on('cursorActivity',onCursor);
inCodeMirror.on('change',onChange);

var inCodeMirrorFrame = new CodeMirrorFrame(inCodeMirror);

var outCodeMirror = CodeMirror.fromTextArea(outArea,{mode:null});

var parseErrors = '';
var warnings    = '';
var errors      = '';

inCodeMirror.setValue(source);

// TODO: - wrap outCodeMirror, state and errors/warnings in object;

// NOTE: CodeMirror callback order - onChange is called before onCursor;
// (re-)parse input if there has been a change
function onChange(editor) {

  inCodeMirrorFrame.clearErrors(true);

  try {
    inCodeMirrorFrame.currentAST = parse(editor.getValue(),{loc:true,range:true});
    parseErrors = warnings = errors =  '';
  } catch (e) {
    parseErrors = 'parse error in source:\n'+e;
    inCodeMirrorFrame.parseError(e);
  }
  outCodeMirror.setValue([parseErrors,warnings,errors].join('\n'));

}

function rightOf(coords) { return {line:coords.line,ch:coords.ch+1}}

// NOTE: CodeMirror callback order - onChange is called before onCursor,
//       so we have a parse result here already
function onCursor(editor) {
    var coords = editor.getCursor();
    var token  = editor.getTokenAt(rightOf(coords));
    // console.log(token);
    if (token && token.className && token.className.match(/variable|def/)) {
      var result = inCodeMirrorFrame.currentAST
                 ? findVar(token.string,{line:coords.line+1,column:coords.ch})
                          ('in',editor.getValue(),inCodeMirrorFrame.currentAST)
                 : null;

      inCodeMirrorFrame.clearCurrentVar();

      inCodeMirrorFrame.clearErrors();

      if (result) {
        if (result.warnings) {
          warnings = result.warnings;
          result.warnings.match(/start: { line: \d+/g)
                         .forEach(function(p){
                            inCodeMirrorFrame.warning(p.match(/\d+/)-1);
                          });
        } else {
          warnings = '';
        }
        if (result.error) {
          errors = result.error.message;
          inCodeMirrorFrame.currentVarMarks.push(
            editor.markText({line:coords.line,ch:token.start}
                           ,{line:coords.line,ch:token.end}
                           ,'currentUnbound'));
          document.getElementById('oldName').value = "";
          document.getElementById('rename').disabled = true;
          navigation_disabled(true);
        } else {
          errors = '';
          document.getElementById('oldName').value = token.string;
          document.getElementById('rename').disabled = false;
          navigation_disabled(false);

          inCodeMirrorFrame.setCurrentVar(result.binding);

          inCodeMirrorFrame.clearUnboundMarks();
          inCodeMirrorFrame.currentAST.freeVars.forEach(function(fv){
            inCodeMirrorFrame.unboundMarks.push(
              editor.markText({line:fv.loc.start.line-1,ch:fv.loc.start.column}
                             ,{line:fv.loc.end.line-1,ch:fv.loc.end.column}
                             ,'Unbound'))
          });
        }
        outCodeMirror.setValue([parseErrors,warnings,errors].join('\n'));
      }
    } else {
      document.getElementById('oldName').value = ""; // +'('+token.className+')';
      document.getElementById('rename').disabled = true;
      navigation_disabled(true);
    }
};

function renameAction() {
  try {
    var coords  = inCodeMirror.getCursor();
    var token   = inCodeMirror.getTokenAt(rightOf(coords));
    var newName = prompt('new name?','x____x');
    var output  = [];
    var matches;

    var renamed =
      parseThen(rename(token.string,{line:coords.line+1,column:coords.ch},newName))
               ('in',inCodeMirror.getValue());
    if (renamed) {
      if (renamed.warnings) {
        output.push(renamed.warnings);
      }
      if (renamed.parseError) { // should have been handled by onCursor
        output.push(renamed.parseError);
      } else if (renamed.error) {
        // console.log('error',renamed.error);
        output.push(renamed.error.message);
        if (matches = renamed.error.message.match(/line: \d+/g)) {
          matches.forEach(function(p){
                            inCodeMirrorFrame.error(p.match(/\d+/)-1);
                          });
        }
      } else {
        inCodeMirror.setValue(renamed.source);
      }
    }
    outCodeMirror.setValue(output.join('\n'));
  } catch (e) { // shouldn't occur anymore?..
    // console.error(e);
    outCodeMirror.setValue('renaming failed (see error log)\n'+e);
  }
}

function refocus(action,repos) { return function() {
  var coords = inCodeMirror.getCursor();
  var scroll = inCodeMirror.getScrollInfo();
  action();
  if (repos) {
    inCodeMirror.setCursor(coords);
    inCodeMirror.scrollTo(scroll.left,scroll.top);
  }
  inCodeMirror.focus();
}}

document.getElementById('rename')
        .addEventListener('click',refocus(renameAction,true),false);
document.getElementById('undo')
        .addEventListener('click',refocus(inCodeMirror.undo.bind(inCodeMirror),true),false);
document.getElementById('redo')
        .addEventListener('click',refocus(inCodeMirror.redo.bind(inCodeMirror),true),false);
document.getElementById('next')
        .addEventListener('click'
                         ,refocus(inCodeMirrorFrame.nextOccurrence(+1))
                         ,false);
document.getElementById('binding')
        .addEventListener('click'
                         ,refocus(inCodeMirrorFrame.nextOccurrence(0))
                         ,false);
document.getElementById('previous')
        .addEventListener('click'
                         ,refocus(inCodeMirrorFrame.nextOccurrence(-1))
                         ,false);

inCodeMirror.focus();

</script>

</body>

</html>
